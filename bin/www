#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('entu:server');
var http = require('http');
var appConfig = require('../config.json');
var async = require('async');
var path = require('path');
var fs = require('fs');
var Log15 = require('../src/utils/log15.js');
var changeCase = require('change-case');
var WorkQueue = require('../src/utils/workqueue.js');

process.stdin.resume();

var versionBuild = fs.readFileSync(path.join(__dirname, '../build'), 'utf8');

var log = new Log15({echo: appConfig.echoLogLevel, recLevel: appConfig.outputLogLevel});

var params = {
    "db": appConfig.db.uri,
    "modules": {
        "loader": "../src/modules/loader.js",
        "peer": "../src/modules/peer.js",
        "server": "../src/modules/server.js",
        "system": "../src/modules/system.js"
    }
}

process.on('uncaughtException', function (err) {
    // handle the error safely
    log.fatal('System error', { message: err.message, stack: err.stack });
    process.emit('cleanup');
});

var d = require('domain').create();
d.on('error', function (err) {
    log.Fatal('Domain master', "Error", err.message, "Stack", err.stack);
    process.exit(0);
});
d.run(function () {
    var modules = [];

    async.auto({
        config: function (cb) {
            cb(null, appConfig);
        },

        log: function (cb) {
            cb(null, log);
        },

        build: function (cb) {
            cb(null, versionBuild);
        },

        public: function (cb) {
            cb(null, path.join(__dirname, '../public'));
        },

        dbWorkQueue: ['log', function (scope, cb) {
            var queue = new WorkQueue({
                onWarning: function (current, limit) {
                    scope.log.Info('DB queue', 'current', current, 'limit', limit);
                }
            });
            cb(null, queue);
        }],

        mainWorkQueue: ['log', function (scope, cb) {
            var queue = new WorkQueue({
                onWarning: function (current, limit) {
                    scope.log.Info('Main queue', 'current', current, 'limit', limit);
                }
            });
            cb(null, queue);
        }],

        balancesWorkQueue: ['log', function (scope, cb) {
            var queue = new WorkQueue({
                onWarning: function (current, limit) {
                    scope.log.Info('balances queue', 'current', current, 'limit', limit);
                }
            });
            cb(null, queue);
        }],

        network: ['config', 'log', 'dbWorkQueue', 'mainWorkQueue', 'balancesWorkQueue', function (scope, cb) {
            var server = http.createServer(app);
            server.on('error', onError);
            server.listen(scope.config.port, scope.config.host, function (err) {
                scope.log.Info('Entu is listening', 'version', scope.config.version, 'host', scope.config.host, 'port', scope.config.port);

                cb(err, {
                    app: app,
                    server: server
                });
            });
        }],

        notification_center: function (cb) {
            var ncenter = function () {
                this.notify = function () {
                    var args = [];
                    Array.prototype.push.apply(args, arguments);
                    var command = args.shift();
                    modules.forEach(function (module) {
                        var eventName = 'on' + changeCase.pascalCase(command);
                        if (typeof(module[eventName]) == 'function') {
                            module[eventName].apply(module[eventName], args);
                        }
                    });
                }
            }
            cb(null, new ncenter);
        },

        modules: ['network', 'notification_center', 'build', 'public', function (scope, cb) {
            var __modules = {};
            Object.keys(params.modules).forEach(function (module_name) {
                __modules[module_name] = function (cb) {
                    var d = require('domain').create();
                    d.on('error', function (err) {
                        scope.log.Fatal('Domain ' + module_name, "Error", err.message, "Stack", err.stack);
                    });
                    d.run(function () {
                        scope.log.Debug('Loading module ' + module_name);
                        var Klass = require(params.modules[module_name]);
                        var obj = new Klass(cb, scope);
                        modules.push(obj);
                    });
                }
            });
            async.parallel(__modules, function (err, modules) {
                cb(err, modules);
            })
        }],

        ready: ['network', 'modules', 'notification_center', function (scope, cb) {
            scope.notification_center.notify('init', scope.modules);
            cb();
        }]
    }, function (err, scope) {
        if (err) {
            scope.log.Fatal(err.toString());
        }

        scope.log.Info('Modules are initialized and launched');

        process.once('cleanup', function () {
            scope.log.Info('Cleaning up...');


            process.exit(1);
        });

        process.once('SIGTERM', function () {
            process.emit('cleanup');
        });

        process.once('exit', function () {
            process.emit('cleanup');
        });

        process.once('SIGINT', function () {
            process.emit('cleanup');
        });
    })
});

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
        log.Fatal('port requires elevated privileges');
          process.exit(1);
          break;
    case 'EADDRINUSE':
        log.Fatal('port or address is already in use');
          process.exit(1);
          break;
    default:
        throw error;
  }
}
