#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('entu:server');
var http = require('http');
var appConfig = require('../config.json');
var genesisblock = require('../genesisBlock.json');
var async = require('async');
var path = require('path');
var fs = require('fs');
var Log15 = require('../src/utils/log15.js');
var changeCase = require('change-case');
var WorkQueue = require('../src/utils/workqueue.js');
var Sequelize = require('sequelize');
var z_schema = require('z-schema');

process.stdin.resume();

var versionBuild = fs.readFileSync(path.join(__dirname, '../build'), 'utf8');

var log = new Log15({echo: appConfig.echoLogLevel, recLevel: appConfig.outputLogLevel});

var params = {
    "db": appConfig.db.uri,
    "modules": {
        "loader": "../src/modules/loader.js",
        "peers": "../src/modules/peers.js",
        "server": "../src/modules/server.js",
        "system": "../src/modules/system.js"
    }
}

process.on('uncaughtException', function (err) {
    // handle the error safely
    log.fatal('System error', { message: err.message, stack: err.stack });
    process.emit('cleanup');
});

var d = require('domain').create();
d.on('error', function (err) {
    log.Fatal('Domain master', "Error", err.message, "Stack", err.stack);
    process.exit(0);
});
d.run(function () {
    var modules = [];

    async.auto({
        config: function (cb) {
            cb(null, appConfig);
        },

        log: function (cb) {
            cb(null, log);
        },

        build: function (cb) {
            cb(null, versionBuild);
        },

        genesisblock: function (cb) {
            cb(null, {
                block: genesisblock
            });
        },

        public: function (cb) {
            cb(null, path.join(__dirname, '../public'));
        },

        schema: function (cb) {
            z_schema.registerFormat('splitArray', function (str) {
                try {
                    var arr = str.split(',');
                    if (arr.length > 0 && a.length <= 1000) {
                        return true;
                    } else {
                        return false;
                    }
                } catch (err) {
                    return false;
                }
            });

            z_schema.registerFormat('signature', function (str) {
                if (str.length === 0) {
                    return true;
                }

                try {
                    var signature = new Buffer(str, 'hex');
                    return signature.length == 64;
                } catch (err) {
                    return false;
                }
            });

            z_schema.registerFormat('listQuery', function (obj) {
                obj.limit = 100;
                return true;
            });

            z_schema.registerFormat('listDelegates', function (obj) {
                obj.limit = 101;
                return true;
            });

            z_schema.registerFormat('checkInt', function (value) {
                if (isNaN(value) || parseInt(value) != value || isNaN(parseInt(value, 10))) {
                    return false;
                }

                value = parseInt(value);
                return true;
            });

            z_schema.registerFormat('ip', function (str) {

            });

            cb(null, new z_schema());
        },

        dbWorkQueue: ['log', function (scope, cb) {
            var queue = new WorkQueue({
                onWarning: function (current, limit) {
                    scope.log.Info("DB queue", "current", current, "limit", limit);
                }
            });
            cb(null, queue);
        }],

        mainWorkQueue: ['log', function (scope, cb) {
            var queue = new WorkQueue({
                onWarning: function (current, limit) {
                    scope.log.Info("Main queue", "current", current, "limit", limit);
                }
            });
            cb(null, queue);
        }],

        balancesWorkQueue: ['log', function (scope, cb) {
            var queue = new WorkQueue({
                onWarning: function (current, limit) {
                    scope.log.Info("Balance queue", "current", current, "limit", limit);
                }
            });
            cb(null, queue);
        }],

        dbClient: ['config', 'log', 'genesisblock', function (scope, cb) {
            var sequelize = new Sequelize(scope.config.db.name, scope.config.db.user, scope.config.db.password, {
                host: scope.config.db.host,
                dialect: 'mysql',
                logging: false,
                pool: {
                    max: 10,
                    min: 0,
                    acquire: 30000,
                    idle: 30000
                }
            });
            cb(null, sequelize);
        }],

        network: ['dbWorkQueue', 'mainWorkQueue', 'balancesWorkQueue', 'dbClient', function (scope, cb) {
            var server = http.createServer(app);
            server.on('error', onError);
            server.listen(scope.config.port, scope.config.address, function (err) {
                scope.log.Info("Entu is listening", "version", scope.config.version, "address", scope.config.address, 'port', scope.config.port);

                cb(err, {
                    app: app,
                    server: server
                });
            });
        }],

        notification_center: function (cb) {
            var ncenter = function () {
                this.notify = function () {
                    var args = [];
                    Array.prototype.push.apply(args, arguments);
                    var command = args.shift();
                    modules.forEach(function (module) {
                        var eventName = 'on' + changeCase.pascalCase(command);
                        if (typeof(module[eventName]) == 'function') {
                            module[eventName].apply(module[eventName], args);
                        }
                    });
                }
            }
            cb(null, new ncenter);
        },

        base: ['config', 'log', 'genesisblock', 'dbClient', 'notification_center', function (scope, cb) {
            var Account = require('../src/base/Account.js');
            var Peers = require('../src/base/peer.js');
            var Peeer = require('../src/base/peeer.js');

            async.auto({
                config: function (cb) {
                    cb(null, scope.config);
                },
                genesisblock: function (cb) {
                    cb(null, scope.genesisblock);
                },
                log: function (cb) {
                    cb(null, scope.log);
                },
                dbClient: function (cb) {
                    cb(null, scope.dbClient);
                },
                notification_center: function (cb) {
                    cb(null, scope.notification_center);
                },
                account: ['log', 'dbClient', 'notification_center', function (scope, cb) {
                    new Account(scope, cb);
                }],
                peer: ['dbClient', 'notification_center', 'log', function (scope, cb) {
                    new Peers(scope, cb);
                }],
                peeer: ['dbClient', 'notification_center', 'log', function (scope, cb) {
                    new Peeer(scope, cb);
                }],
            }, cb);
        }],

        modules: ['network', 'notification_center', 'base', function (scope, cb) {
            var __modules = {};
            Object.keys(params.modules).forEach(function (module_name) {
                __modules[module_name] = function (cb) {
                    var d = require('domain').create();
                    d.on('error', function (err) {
                        scope.log.Fatal('Domain ' + module_name, "Error", err.message, "Stack", err.stack);
                    });
                    d.run(function () {
                        scope.log.Debug("Loading module " + module_name);
                        var Klass = require(params.modules[module_name]);
                        var obj = new Klass(cb, scope);
                        modules.push(obj);
                    });
                }
            });
            async.parallel(__modules, function (err, modules) {
                cb(err, modules);
            })
        }],

        ready: ['network', 'modules', 'notification_center', function (scope, cb) {
            scope.notification_center.notify('init', scope.modules);
            cb();
        }]
    }, function (err, scope) {
        if (err) {
            scope.log.Fatal(err.toString());
        }

        scope.log.Info("Modules are initialized and launched");

        process.once('cleanup', function () {
            scope.log.Info("Cleaning up...");


            process.exit(1);
        });

        process.once('SIGTERM', function () {
            process.emit('cleanup');
        });

        process.once('exit', function () {
            process.emit('cleanup');
        });

        process.once('SIGINT', function () {
            process.emit('cleanup');
        });
    })
});

function onError(error) {
  if (error.syscall !== 'listen') {
    throw new Error(error);
  }

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
        log.Fatal('port requires elevated privileges');
          process.exit(1);
          break;
    case 'EADDRINUSE':
        log.Fatal('port or address is already in use');
          process.exit(1);
          break;
    default:
        throw new Error(error);
  }
}
